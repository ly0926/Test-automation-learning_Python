### 变量和常量

变量就是可以变化的量，量即事物的状态，比如人的年龄、体重，工资等等。
相反，常量是指在程序运行过程中，不会或不应该被改变的固定的值，比如圆周率PI = 3.14。

#### 变量的定义和使用

###### 变量的定义由三部分组成：变量名 = 变量值 。比如

```Python
name = 'Jack'
age = 18
sex = '男'
```
解释器在执行到变量定义的代码时会申请内存空间，来存放变量值，然后将变量值的内存地址绑定给变量名，因此，我们可以通过变量名引用到对应的值。比如
```Python
print(age) # 通过变量名age找到值18，然后通过print()函数将其打印出来,输出：18
```

###### 变量名的命名规范

1. 变量名只能是字母、数字或下划线的任意组合，并且不能以数字开头。
2. 关键字不能声明为变量名
3. 变量名的命名应该见名知意
4. 大小写敏感

Python中的所有关键字：
```Python
import keyword

print(keyword.kwlist)
```

###### 变量值的三大特性

变量的值具备三大特性
1、id 反应的是变量在内存中的唯一编号，内存地址不同id肯定不同
2、type 变量值的类型
3、value 变量值

```Python
>>> x='hello world'
>>> id(x),type(x),x
4376607152，<class 'str'>,'hello world'
```

在Python中没有一个专门的语法定义常量，约定俗成是用全部大写的变量名表示常量。如：PI=3.14。所以单从语法层面去讲，常量的使用与变量完全一致。

### 编码

##### 编码表

这里先说下2进制，就是0，1，由于计算机只认识这俩数字，其他的都不认识，这样的0或1为一"位"，规定8位为一个字节，字节是表示现实世界字符的最基本的一个单元，比如一个英文字母，一个字节是8位，也就是最多能存8个0或者1，8位二进制最大值是255，好了，计算机只认识0和1，那怎么表示一些英文字母、汉字、以及标点符号呢？因为计算机是美国人发明的，然后他们就创造了ASCII码，就是用数字来代表这些符号，遇到这些数字就是知道代表的是啥了，然后数字再转化成二进制存入到计算机里，美国人用127个数字，代表了所有的英文大小写字母和符号，这就是ASCII码表，那么问题来了，当世界各地都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，然后为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号。但是前面已经说了，一个字节最大存的数字是255，老美这帮哥们已经用了127个了，剩下的不够啊，像汉字最起码有好几万，这可怎么办呢，中国人就是聪明，那咱就少用点，取了127后面的一些数字，具体用的多少可以自己查一查，然后只要遇到这个区间的数字，就知道是中文，去另一个编码表里面找，这个里面存的都是中文，还有其他国家的文件，比如说日文，韩文等等，这个叫做gb2312编码，它收录了6000+个汉字，这样的话，就解决了计算机不认识中文的问题。但是中国文化，博大精深，岂止有6000+个汉字，然后又有了gbk、Unicode、UTF-8等等编码，Unicode编码也叫万国码，哪个国家的文字都适用，但是它不管你是一个英文字母，还是一个汉字都是占2个字节大小，原来ASCII码一个英文字母就占一个字节，这一下变大了，原来100G的东西，现在可能得200G才存的下，这样明显不合适，然后就又出现了UTF-8字符集，它也属于Unicode，和Unicode的不一样的是，它对Unicode做了压缩，比如说英文字母还是占一个字节，这样的话，就节省的很多空间，这就是为什么现在大家都用utf8的原因。

以打开一个应用为例，从计算机将该程序数据从硬盘读入内存，以及在程序运行期间发生的数据读写等都在发生着编码与解码。

### python的垃圾回收机制

(个人理解较浅，希望以后有时间能看下源码)
##### 小整数池

整数在程序中的使用非常广泛，Python为了优化速度，使用了小整数对象池， 避免为整数频繁申请和销毁内存空间。
Python 对小整数的定义是 [-5, 257) 这些整数对象是提前建立好的，不会被垃圾回收。在一个 Python 的程序中，所有位于这个范围内的整数使用的都是同一个对象.
同理，单个字母也是这样的。

#####引用计数

引用计数的原理是每个对象维护一个ob_ref，用来记录当前对象被引用的次数，当发生以下四种情况的时候，该对象的引用计数器+1
1. 对象被创建  a=14
2. 对象被引用  b=a
3. 对象被作为参数,传到函数中   func(a)
4. 对象作为一个元素，存储在容器中   List={a,”a”,”b”,2}
 
与上述情况相对应，当发生以下四种情况时，该对象的引用计数器-1
1. 当该对象的别名被显式销毁时  del a
2. 当该对象的引别名被赋予新的对象，   a=26
3. 一个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会）
4. 将该元素从容器中删除时，或者容器被销毁时。

当指向该对象的内存的引用计数器为0的时候，即表示该对象未被其他任何对象引用，则被回收掉。

优点：简单、实时（将处理垃圾时间分摊到运行代码时，而不是等到一次回收）、易于实现。
缺点：
1.保存对象引用数会占用一点点内存空间
2.循环引用
```Python
list1 = []
list2 = []
list1.append(list2)
list2.append(list1)
#list1与list2相互引用，如果不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。
```

##### 标记-清除

针对循环引用的情况，Python引入了Generational GC算法
```Python
#『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？
#对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。

#1、标记
#通俗地讲就是：栈区相当于“根”，凡是从根出发可以访达（直接或间接引用）的，都称之为“有根之人”，有根之人当活，无根之人当死。
#具体地：标记的过程其实就是，遍历所有的GC Roots对象(栈区中的所有内容或者线程都可以作为GC Roots对象），然后将所有GC Roots的对象可以直接或间接访问到的对象标记为存活的对象，其余的均为非存活对象，应该被清除。

#2、清除
#清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。
```
基于引用计数的回收机制，每次回收内存，都需要把所有对象的引用计数都遍历一遍，这是非常消耗时间的，于是引入了分代回收来提高回收效率，分代回收采用的是用“空间换时间”的策略。

##### 分代回收

分代回收的核心思想是：在历经多次扫描的情况下，都没有被回收的变量，gc机制就会认为，该变量是常用变量，gc对其扫描的频率会降低，
```Python
#分代指的是根据存活时间来为变量划分不同等级（也就是不同的代）
#新定义的变量，放到新生代这个等级中，假设每隔1分钟扫描新生代一次，如果发现变量依然被引用，那么该对象的权重（权重本质就是个整数）加一，当变量的权重大于某个设定得值（假设为3），会将它移动到更高一级的青春代，青春代的gc扫描的频率低于新生代（扫描时间间隔更长），假设5分钟扫描青春代一次，这样每次gc需要扫描的变量的总个数就变少了，节省了扫描的总时间，接下来，青春代中的对象，也会以同样的方式被移动到老年代中。也就是等级（代）越高，被垃圾回收机制扫描的频率越低

#回收依然是使用引用计数作为回收的依据
```

